package computerscience.java.tick1star;


public class InspectDouble {

public static double power(int x, int p){
double product = 1; 
if (p >= 0){for (int i=1; i<=p; i++){product *= x;} } else {for (int j=-1; j>=p; j--) {product/=x;}}
return product;
}

public static void main(String[] args) throws Exception {
double d = Double.parseDouble(args[0]);
// return the bits which represent the floating point number
long bits = Double.doubleToLongBits(d);
// Sign bit located in bit 63
// Suggested Mask 0x8000000000000000L
// Format 1 => number is negative
// TODO: fill in the XXXX
boolean negative = ((bits>>63)%2) != 0;
// Exponent located in bits 52 - 62
// Suggested Mask 0x7ff0000000000000L
// format Sum( 2^n * e(n)) - 1023 (binary number with bias)
// TODO: fill in the XXXX
long result = 0; 
for(int i = 52; i <=62; i++) {if (((bits>>i)%2)!=0) {result+= (power(2,i-52));} else {result=result;}}
long exponent=result - 1023;
// Mantissa located in bits 0 - 51
// Mask left as an exercise for the reader
// format 1 + Sum(2^-(n+1) * m(n) )
// TODO: fill in the XXXX
double mantissabits = 1;
for(int j = 0; j <=51; j++) {if (((bits>>j)%2)!=0) {mantissabits+= (power(2,(j-52)));} else {mantissabits=mantissabits;}}
//double mantissa = mantissaToDecimal(mantissabits);
System.out.println((negative ? "-" : "") + mantissabits + " x 2^" + exponent);

//System.out.println((negative ? "-" : "") + mantissa + " x 2^" + exponent);

//Confused about the point of the next method. Notes suggest to use this, along with the formula for mantissa 4 lines up. Above line also suggested for final print.

//}
//private static double mantissaToDecimal(long mantissabits) {
//long one = 0x0010000000000000L;
//return (double)(mantissabits + one) / (double)one;
//}
}
